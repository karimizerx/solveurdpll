                      Mini-projet 1 : solveur DPLL récursif
                             fichier RENDU
                       (à remplir obligatoirement)

**Un mini-projet sans fichier RENDU rempli ne recevra pas de note.**

Date limite: 3 novembre 2023, 23h59

Identité
--------
Nombre de binôme: 10
Nom, prénom 1: LAÏDOUNI Mohamed
Nom, prénom 2: KHEMAKHEM Ayman


Questions sur votre code
------------------------
0. Avez-vous testé que `make dpll` s'exécute sans erreurs ou warnings,
   et que ensuite `./dpll sudoku-4x4.cnf` donne la réponse attendue (voir
   fichier README) ?

Oui, `make dppl` s'exécte sans erreurs ou warnings. Et `./dpll sudoku-4x4.cnf` donne bien la réponse attendue (présente dans le README).

---

1. Avez-vous utilisé la fonction `filter_map` (donné dans dpll.ml)
   dans votre implémentation de `simplifie` ? 
   - Si oui, expliquez en quelques phrases en français comment vous
     l'avez utilisée.
   - Si non, expliquez en quelques phrases en français comment
     fonctionne votre implémentation de `simplifie`.

Nous avons simplifie de deux manières : avec et sans `filter_map` :
   1. Avec `filter_map`, nous avons appliqué à chaque clause une fonction qui renvoie:
      - `None` s'il faut supprimer la clause, i.e le littéral `l` appartient à cette clause.
      - `Some clause` en supprimant le littéral `not(l)` de la clause.
   2. Sans `filter_map`, simplifie devient récurssive, et nous avons appliqué un pattern matching sur l'ensemble des clauses, avec disjonction de trois cas :
      - la liste des clauses est vide -> On renvoie la liste `[]`.
      - la clause actuelle contient le littéral `l` -> On supprime cette liste et on continue.
      - la clause actuelle contient le littéral `not(l)` ou non -> On supprime le littéral `not(l)` si nécessaire et on continue.

---

2. Pour l'implémentation de `unitaire`, quelles sont les fonctions
   auxiliaires que vous avez utilisées et/ou écrites ? (Par une
   fonction auxiliaire, on entend ici soit une fonction d'une
   bibliothèque, par exemple des fonctions comme `List.length`,
   `List.rev_append`, ou une fonction `aux_unitaire` que vous avez
   écrite vous-mêmes.) Expliquez en quelques phrases en français
   comment ces fonctions auxiliaires sont utilisées dans votre
   implémentation de la fonction `unitaire`.

Pour l'implémentation de `unitaire`, nous n'avons utilisé aucune fonction auxiliaire. Celle-ci est récursive, et utilise un pattern matching sur chaque clause :
   - si on trouve une clause de type `p :: []`, i.e une clause avec seulement une proposition `p`, alors elle est unitaire et on l'a renvoie.
   - si on tombe sur la liste vide, on lève une exception `Not_found` à l'aide de la fonction `raise`

---

3. Pour l'implémentation de `pur`, quelles sont les fonctions
   auxiliaires que vous avez utilisées et/ou écrites ?  Expliquez en
   quelques phrases en français comment ces fonctions auxiliaires sont
   utilisées dans votre implémentation de la fonction `pur`.

Pour l'implémentation de `pur`, nous avons utilisé plusieurs fonctions auxiliaires :


---

4. Donnez un exemple d'une formule pour laquelle les deux fonctions
   `solveur_split` et `solveur_dpll_rec` ont un comportement
   différent, et expliquez les différences entre ces deux fonctions.

**à remplir**

---

5. Avez-vous d'autres remarques sur votre rendu ? (question optionnelle)

**à remplir**

---

--fin du fichier RENDU--